import os
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import Dict, Optional

import numpy as np
from scipy.linalg import eigh, inv

from PAOFLOW_QTpy.grid.rgrid import get_rgrid
from PAOFLOW_QTpy.io.log_module import (
    log_proj_data,
    log_rank0,
    log_section_end,
    log_section_start,
)
from PAOFLOW_QTpy.io.write_data import (
    write_intermediate_files,
)
from PAOFLOW_QTpy.io.write_header import headered_function
from PAOFLOW_QTpy.parsers.atmproj_parser_base import (
    parse_eigenvalues,
    parse_header,
    parse_kpoints,
    parse_overlaps,
    parse_projections,
)
from PAOFLOW_QTpy.parsers.qexml import qexml_read_cell
from PAOFLOW_QTpy.utils.timing import timed_function


def validate_input(file_proj: str) -> str:
    savedir = os.path.dirname(file_proj)
    file_data = os.path.join(savedir, "data-file.xml")
    if not os.path.exists(file_data):
        raise FileNotFoundError(f"Expected data-file.xml at: {file_data}")
    return file_data


def convert_energy_units(proj_data: Dict) -> Dict:
    proj_data["eigvals_raw"] = proj_data["eigvals"]
    proj_data["efermi_raw"] = proj_data["efermi"]

    unit = proj_data["energy_units"].lower()
    factors = {
        "ha": 27.211386018,
        "hartree": 27.211386018,
        "au": 27.211386018,
        "ry": 13.605693009,
        "ryd": 13.605693009,
        "rydberg": 13.605693009,
        "ev": 1.0,
        "electronvolt": 1.0,
    }
    if unit not in factors:
        raise ValueError(f"Unknown energy unit: {unit}")
    factor = factors[unit]

    proj_data["efermi"] = proj_data["efermi_raw"] * factor
    proj_data["eigvals"] = proj_data["eigvals_raw"] * factor - proj_data["efermi"]
    return proj_data


def log_proj_summary(proj_data: Dict, **kwargs) -> None:
    for line in log_proj_data(proj_data, **kwargs):
        log_rank0(line)


@timed_function("atmproj_to_internal")
@headered_function("Conductor Initialization")
def parse_atomic_proj(
    *,
    input_dict: Optional[Dict] = None,
    file_proj: str,
    work_dir: str,
    prefix: str = "",
    postfix: str = "",
    atmproj_sh: float = 10.0,
    atmproj_thr: float = 0.0,
    atmproj_nbnd: Optional[int] = None,
    atmproj_do_norm: bool = False,
    do_orthoovp: bool = True,
    write_intermediate: bool = True,
) -> Dict[str, np.ndarray]:
    file_data = validate_input(file_proj)
    log_rank0(f"  {file_proj} file fmt: atmproj")

    lattice_data = qexml_read_cell(file_data)
    proj_data = parse_atomic_proj_xml(file_proj, lattice_data)
    proj_data = convert_energy_units(proj_data)

    log_proj_summary(
        proj_data,
        atmproj_sh=atmproj_sh,
        atmproj_thr=atmproj_thr,
        atmproj_nbnd=atmproj_nbnd,
        atmproj_do_norm=atmproj_do_norm,
        do_orthoovp=do_orthoovp,
    )

    log_section_start("atmproj_read_ext --massive data")
    hk_data = build_hamiltonian_from_proj(
        proj_data,
        atmproj_sh=atmproj_sh,
        atmproj_thr=atmproj_thr,
        atmproj_nbnd=atmproj_nbnd,
        do_orthoovp=do_orthoovp,
    )
    log_section_end("atmproj_read_ext --massive data")

    nk = np.array([1, 1, 4], dtype=int)  # TODO: confirm this hardcoded grid
    nr = nk
    ivr, wr = get_rgrid(nr)
    hk_data.update({"ivr": ivr, "wr": wr, "nk": nk, "nr": nr})

    if write_intermediate:
        write_intermediate_files(
            file_proj,
            work_dir,
            prefix,
            postfix,
            hk_data,
            proj_data,
            lattice_data,
            do_orthoovp,
        )

    return hk_data


def parse_atomic_proj_xml(file_proj: str, lattice_data: Dict) -> Dict:
    """
    Parse the Quantum ESPRESSO atomic_proj.xml file (from projwfc.x) into structured NumPy arrays.

    Parameters
    ----------
    file_proj : str
        Path to the atomic_proj.xml file generated by QE's projwfc.x. This XML file contains
        the bandstructure eigenvalues, k-point grid, projection data, and optionally, overlaps.
    lattice_data : dict
        Dictionary containing lattice parameters, including:
        - `alat` : float
            Lattice constant in Bohr.
        - `bvec` : (3, 3) ndarray
            Reciprocal lattice vectors in columns (Bohr^-1).

    Returns
    -------
    dict
        A dictionary containing:
        - `nbnd` : int
            Number of bands.
        - `nkpts` : int
            Number of k-points.
        - `nspin` : int
            Number of spin components (1 for non-magnetic, 2 for collinear magnetic calculations).
        - `natomwfc` : int
            Number of atomic wavefunctions (projectors) in the system.
        - `nelec` : float
            Number of electrons in the system.
        - `efermi` : float
            Fermi energy in the units specified by `energy_units`.
        - `energy_units` : str
            Units of energy (e.g., 'eV', 'Ha', 'Ry') as specified in the XML file.
        - `kpts` : ndarray of shape (3, nkpts)
            K-point coordinates in crystal units, transposed for consistency with PAOFLOW conventions.
        - `wk` : ndarray of shape (nkpts,)
            K-point weights.
        - `eigvals` : ndarray of shape (nbnd, nkpts, nspin)
            Eigenvalues of the bands at each k-point and spin.
        - `proj` : ndarray of shape (natomwfc, nbnd, nkpts, nspin), complex
            Projection matrix elements ⟨atomic_wfc | Bloch_state⟩.
        - `overlap` : ndarray of shape (natomwfc, natomwfc, nkpts, nspin), complex or None
            Overlap matrices S_{ij}(k) = ⟨atomic_wfc_i | atomic_wfc_j⟩ if present in the XML; else None.

    Notes
    -----
    The function performs the following steps:
    - Logs the start of eigenvalue and projection parsing.
    - Reads XML sections: HEADER, K-POINTS, WEIGHT_OF_K-POINTS, EIGENVALUES, PROJECTIONS, and optional OVERLAPS.
    - Supports both single and spin-polarized cases (1 or 2 spin channels).

    The projection matrix `proj` stores complex coefficients:
        `proj[ias, ib, ik, isp] = ⟨ atomic_wfc (ias) | Bloch_state (ib, ik, isp) ⟩`.

    The eigenvalues `eigvals` are:
        `eigvals[ib, ik, isp] = E_{ib}(k, spin)`, where `ib` is the band index.

    The overlap matrices `overlap` (if present) are:
        `overlap[i, j, ik, isp] = ⟨ atomic_wfc_i | atomic_wfc_j ⟩ at k-point ik, spin isp`.

    All arrays are stored in NumPy-friendly formats with dtype float64 or complex128.

    The XML structure parsed corresponds to QE's projwfc.x output:
    - HEADER block with general info.
    - K-POINTS and WEIGHT_OF_K-POINTS blocks.
    - EIGENVALUES and PROJECTIONS blocks, nested by k-points and optionally by spin.
    - OVERLAPS block if present.
    """

    log_section_start("atmproj_read_ext")
    log_section_start("reading eigenvalues")

    tree = ET.parse(file_proj)
    root = tree.getroot()

    header = parse_header(root)
    kpt_data = parse_kpoints(root, lattice_data)
    eigvals = parse_eigenvalues(root, header["nbnd"], header["nkpts"], header["nspin"])

    log_section_end("reading eigenvalues")

    log_section_start("reading projections")
    proj = parse_projections(
        root, header["nbnd"], header["nkpts"], header["nspin"], header["natomwfc"]
    )

    log_section_end("reading projections")
    log_section_end("atmproj_read_ext")

    overlap = parse_overlaps(root, header["nkpts"], header["nspin"], header["natomwfc"])

    return {**header, **kpt_data, "eigvals": eigvals, "proj": proj, "overlap": overlap}


def build_hamiltonian_from_proj(
    proj_data: Dict,
    atmproj_sh: float,
    atmproj_thr: float,
    atmproj_nbnd: Optional[int],
    do_orthoovp: bool,
    atmproj_do_norm: bool = False,
    shifting_scheme: int = 1,
) -> Dict[str, np.ndarray]:
    """
    Construct H(k) from projection data.

    Parameters
    ----------
    `proj_data` : Dict
        Output from parse_atomic_proj_xml.
    `atmproj_sh` : float
        Energy shift used as a band filter.
    `atmproj_thr` : float
        Minimum projector weight to include a band.
    `atmproj_nbnd` : int or None
        Maximum number of bands to include.
    `do_orthoovp` : bool
        If False, include the non-orthogonal overlaps. If True, projector basis has been orthonormalized.
    `atmproj_do_norm` : bool
        If True, normalize the projectors.
    `shifting_scheme` : int
        1 = direct sum over projectors; 2 = projected subspace with inverse PA

    Returns
    -------
    Dict[str, np.ndarray]
        Includes keys:
        - 'Hk': complex ndarray, shape (nspin, nkpts, natomwfc, natomwfc)
        - 'S' : complex ndarray, shape (natomwfc, natomwfc, nkpts, nspin) if available

    Notes
    -----
    Two schemes are used for constructing the k-dependent Hamiltonian:

    1. **Shifting scheme 1 (default):**

       The Hamiltonian is constructed from the outer product of the projectors:

           H(k) = ∑_b [eig_b(k) - κ] · |proj_b(k)><proj_b(k)|

       where the summation runs over bands b with eigenvalues below `atmproj_sh` κ.
       Optional projector normalization is applied before the outer product.

    2. **Shifting scheme 2 (subspace projection):**

       Let A be the matrix whose columns are selected projectors for eigenvalues < κ:

           A_{i b} = <ϕ_i | ψ_b>

       Let E be a diagonal matrix with corresponding eigenvalues:

           E_{bb} = eig_b(k)

       Define the projector overlap:

           PA = A⁺ · A

       Compute its inverse, IPA = (A⁺ A)⁻¹. Then construct:

           H_aux = (E - κ IPA) · A⁺
           H(k) = A · H_aux = A · (E - κ IPA) · A⁺

       This is a more accurate low-rank projection of the Hamiltonian into the atomic subspace.

    In both cases, a final shift of +κ is added to the Hamiltonian either as:
    - H(k) += κ · S(k) for non-orthogonal basis
    - H(k) += κ · I for orthonormal basis

    If `do_orthoovp` is False, an additional transformation is applied:
        H(k) -> S(k)½ · H(k) · S(k)½
    where S(k)½ is the square root of the overlap matrix.
    """
    eig = proj_data["eigvals"]
    proj = proj_data["proj"]
    S_raw = proj_data["overlap"]

    nbnd = proj_data["nbnd"]
    nkpts = proj_data["nkpts"]
    nspin = proj_data["nspin"]
    natomwfc = proj_data["natomwfc"]

    opts = HamiltonianOptions(
        sh=atmproj_sh,
        thr=atmproj_thr,
        nbnd=atmproj_nbnd,
        do_norm=atmproj_do_norm,
        do_orthoovp=do_orthoovp,
        shifting_scheme=shifting_scheme,
    )

    atmproj_nbnd_ = (
        min(atmproj_nbnd, nbnd) if atmproj_nbnd and atmproj_nbnd > 0 else nbnd
    )
    Hk = np.zeros((nspin, nkpts, natomwfc, natomwfc), dtype=np.complex128)
    Sk = S_raw.copy() if not opts.do_orthoovp and S_raw is not None else None

    for isp in range(nspin):
        for ik in range(nkpts):
            if opts.shifting_scheme == 2:
                H = build_scheme2(eig, proj, ik, isp, opts, natomwfc)
            else:
                H = build_scheme1(eig, proj, ik, isp, opts, atmproj_nbnd_, natomwfc)

            if not opts.do_orthoovp and S_raw is not None:
                H = apply_overlap_transformation(H, S_raw[:, :, ik, isp])

            if not opts.do_orthoovp and S_raw is not None:
                H += opts.sh * S_raw[:, :, ik, isp]
            else:
                H += opts.sh * np.eye(natomwfc, dtype=np.complex128)

            enforce_hermiticity(H, opts.hermitian_tol, ik, isp)
            Hk[isp, ik] = H

    return {"Hk": Hk, "S": Sk}


@dataclass
class HamiltonianOptions:
    sh: float
    thr: float
    nbnd: Optional[int]
    do_norm: bool
    do_orthoovp: bool
    shifting_scheme: int = 1
    hermitian_tol: float = 1e-8


def build_scheme1(
    eig: np.ndarray,
    proj: np.ndarray,
    ik: int,
    isp: int,
    opts: HamiltonianOptions,
    atmproj_nbnd_: int,
    natomwfc: int,
) -> np.ndarray:
    H = np.zeros((natomwfc, natomwfc), dtype=np.complex128)
    for ib in range(atmproj_nbnd_):
        energy = eig[ib, ik, isp]
        if opts.thr > 0.0:
            proj_b = proj[:, ib, ik, isp]
            weight = np.vdot(proj_b, proj_b).real
            if energy > opts.sh or weight < opts.thr:
                continue
        else:
            if energy >= opts.sh:
                continue
            proj_b = proj[:, ib, ik, isp]
            weight = np.vdot(proj_b, proj_b).real

        if opts.do_norm and weight > 1e-14:
            proj_b /= np.sqrt(weight)

        H += (energy - opts.sh) * np.outer(proj_b, proj_b.conj())
    return 0.5 * (H + H.conj().T)


def build_scheme2(
    eig: np.ndarray,
    proj: np.ndarray,
    ik: int,
    isp: int,
    opts: HamiltonianOptions,
    natomwfc: int,
) -> np.ndarray:
    mask = [ib for ib in range(eig.shape[0]) if eig[ib, ik, isp] < opts.sh]
    if not mask:
        raise RuntimeError(f"No eigenvalues below shift at ik={ik}")

    E = np.diag(eig[mask, ik, isp])
    A = proj[:, mask, ik, isp].copy()

    if opts.do_norm:
        for ib in range(A.shape[1]):
            norm = np.vdot(A[:, ib], A[:, ib]).real
            if norm > 1e-14:
                A[:, ib] /= np.sqrt(norm)

    PA = A.conj().T @ A
    IPA = inv(PA)
    H_aux = (E - opts.sh * IPA) @ A.conj().T
    H = A @ H_aux
    return 0.5 * (H + H.conj().T)


def apply_overlap_transformation(H: np.ndarray, S: np.ndarray) -> np.ndarray:
    w, U = eigh(S)
    if np.any(w <= 0):
        raise ValueError("Negative or zero overlap eigenvalue")
    sqrtS = U @ np.diag(np.sqrt(w)) @ U.conj().T
    return sqrtS @ H @ sqrtS.conj().T


def enforce_hermiticity(H: np.ndarray, tol: float, ik: int, isp: int) -> None:
    if not np.allclose(H, H.conj().T, atol=tol):
        raise ValueError(f"H(k) not Hermitian at ik={ik}, isp={isp}")
